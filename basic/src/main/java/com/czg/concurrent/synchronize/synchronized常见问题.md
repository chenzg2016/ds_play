#synchronized常见问题

`1.` Synchronized 用过吗，其原理是什么？

每个对象都有一个监视器锁,就是常说的monitor,实现同步的原理是通过monitor enter和monitor exit两条指令,
monitor enter就是monitor被占用时,
就是处于锁定状态,线程执行monitor enter指令就是尝试获取monitor所有权.

``a.``如果monitor进入数是0,则该线程进入monitor,然后将monitor进入数设置为1,该线程
即为monitor所有者.
``b.``如果该线程已经占有该monitor,只是重新进入,那么monitor进入数加1.
``c.``如果其它线程已经占用了monitor,则该线程进入阻塞状态,直到monitor进入数为0,再重新尝试获取monitor的所有权.
  
执行monitor exit的线程必须是object ref所对应的monitor的所有者。

指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。
其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 
     
 `2.`你刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？
       锁其实就是临界资源,从 jvm 角度看是类的成员变量在堆上,类的静态常量在方法区,而非栈区数据，这个对线程来说是私有的.
  `3.` 什么是可重入性，为什么说 Synchronized 是可重入锁？
  已经持有锁的线程可以再次进入临界区,并且可以计数进入次数，Synchronized就是通过monitor enter和monitor exit实现了该该特性,
  所以才 叫做可重入锁.
  `4.` JVM 对JAVA原生锁做了哪些优化?
  
  由于Java层面的线程与操作系统的原生线程有映射关系，如果要将一个线程进行阻塞或唤起都需要操作系统的协助，这就需要从用户态切换到内核态来执行，这种切换代价十分昂贵，很耗处理器时间，现代JDK中做了大量的优化。一种优化是使用自旋锁，即在把线程进行阻塞操作之前先让线程自旋等待一段时间，可能在等待期间其他线程已经解锁，这时就无再让线程执行阻塞操作，避免了用户态到内核态的切换。
  
  再让线程执行阻塞操作，避免了用户态到内核态的切换。
  
  现代JDK中还提供了三种不同的 Monitor实现，也就是三种不同的锁：
  
  + 偏向锁( Biased Locking)
  
  + 轻量级锁
  
  + 重量级锁
  
  这三种锁使得JDK得以优化Synchronized的运行，当JVM检测到不同的竞争状况时，会自动切换到适合的锁实现，这就是锁的升级。
  
  - 当没有竞争出现时，默认会使用偏向锁。
  
  JVM会利用CAS操作，在对象头上的Mark Word部分设置线程ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁，因为在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏向锁可以降低无竞争开销。
  
  - 如果有另一线程试图锁定某个被偏斜过的对象，JVM就撤销偏向锁，切换到轻量级锁实现。
  
  - 轻量级锁依赖CAS操作Mark Word来试图获取锁，如果重试成功，就使用普通的轻量级锁;否则，进一步升级为重量级锁。
  
  `5.` 为什么说 Synchronized 是非公平锁
  
  公平锁：
  获取不到锁的时候，会自动加入队列，等待线程释放后，队列的第一个线程获取锁
  
  非公平锁:
  获取不到锁的时候，会自动加入队列，等待线程释放锁后所有等待的线程同时去竞争
  
  
 `5.`什么是锁消除和锁粗化？
 
 **为了保证数据的完整性，在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。**
 
 - 锁消除的依据是逃逸分析的数据支持
 
 如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于程序员来说这还不清楚么？在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？虽然没有显示使用锁，但是在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法：
 
 
 public void vectorTest(){
     Vector<String> vector = new Vector<String>();
     for(int i = 0 ; i < 10 ; i++){
         vector.add(i + "");
     }
 
     System.out.println(vector);
 }
 
 在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所以JVM可以大胆地将vector内部的加锁操作消除。
 
 在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是 为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。
 
 在大多数的情况下，上述观点是正确的。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。
 
 锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁
 
 如上面实例：
 
 vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。
 
 `7.`为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？
 悲观锁是指认为其他线程必定会同时操作临界资源,所以在操作临界资源之前先上锁,这样获得锁之后，其它线程只能处于阻塞状态.
 乐观锁是认为其他线程不会同时来操作临界资源,操作完临界资源真正提交前才检测是否有冲突,
，如果冲突，则返回给用户异常信息，让用户决定如何去做。
乐观锁的实现一般通过cas+volatile关键字实现.
还有版本号的方式,
 
 `8.` 乐观锁一定就是好的吗？
 不是,乐观锁适用于读多写少的场景，这样可以提高程序的吞吐量。反之写多读少反而性能比较低
 
