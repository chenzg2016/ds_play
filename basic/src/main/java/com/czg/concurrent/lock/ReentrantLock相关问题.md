#可重入锁 ReentrantLock 及其他显式锁相关问题


`1.`跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？
    
使用方式
Synchronized可以修饰实例方法，静态方法，代码块。自动释放锁。

ReentrantLock一般需要try catch finally语句，在try中获取锁，在finally释放锁。需要手动释放锁。

实现方式
Synchronized是重量级锁。重量级锁需要将线程从内核态和用户态来回切换。如：A线程切换到B线程，A线程需要保存当前现场，B线程切换也需要保存现场。这样做的缺点是耗费系统资源。

ReentrantLock是轻量级锁。采用cas+volatile管理线程，不需要线程切换切换，获取锁线程觉得自己肯定能成功，这是一种乐观的思想（可能失败）。

用一个形象例子来说明：比如您在看我这篇文章时，觉得“重量级锁”概念不是很明白，就立刻去翻看关于“重量级锁”的其他文章，过会儿回头再继续往下面看， 这种行为我们称为切换。保存现场的意思就是你大脑需要记住你跳跃的点然后继续阅读，如果文章篇幅大，你的大脑可能需要记忆越多的东西，会越耗费脑神经。同理，在轻量级锁中，你觉得“重量级锁”概念不是很明白，他不会立刻去翻看其他文章，他会坚持会儿继续看，如果实在不明白再去翻资料了。需要注意的是：这是两种不一样的思维方式，前者是被动阻塞悲观锁，状态是block，后者是主动的阻塞乐观锁，状态是wait。

还可以从公平与非公平、是否可重入、是否可中断、条件队列角度回答区别。
Synchronized是非公平锁，而ReentrantLock既可以是公平锁也可以是非公平锁。
两者都是可重入锁。
Synchronized不可中断,而 ReentrantLock 可以设置为可中断。
Synchronized只有一个等待队列。
ReentrantLock中一把锁可以对应多个条件队列。通过newCondition表示。

`2.`那么请谈谈 AQS 框架是怎么回事儿？
    
AQS框架是 JUC包下实现锁的核心工具类,大部分锁的实现都是通过继承该抽象类来实现.
AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。
它内部实现了一个双向链表来管理多个线程，